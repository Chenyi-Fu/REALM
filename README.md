# Robust Epidemiological AnaLytics Modeling (REALM) toolkit
The repository contains code for a epidemiological model utilized in the research effort of us. Code created by Chenyi Fu (chenyi_fu_201509@163.com) and please CITE the following when you are utilizing our resultsï¼š

Chenyi Fu, Minglong Zhou, Melvyn Sim, Robust Epidemiological Analytics, 2022.

This repository contains multiple files, most of them being archived in the `REALM` folder:
1. `REALM/REAML.py` - The current version of main code implemented in our work. It contains multiple functions and users can implement their deterministic/stochastic/robust epidemiological forecast and deterministic/robust optimization models in a straightforward fashion.
    + Number of compartments $N$, number of population groups $J$, and length of planning horizon $T$;  
    + Name and initial population size of each compartment;  
    + Transition probability $\hat{q}^{m,n}$  
    between each pair of compartments $(m,n)$;   
    + Support set (lower and upper bounds) of decision variables;
    + Cost parameters used in objective function;
    + Coefficients in the operational constraints;
    + Approximation approaches to be adopted, \emph{i.e.,} staircase function approximation, McCormick envelopes, and simulation-optimization iteration;
    + The analytics model to be used. Users can choose to adopt a deterministic/stochastic/robust epidemiological forecast model or a deterministic/robust epidemiological optimization model.  
Note that All code is written in Python 3.6 with CPLEX 12.7 and Gurobi 9.1.2.
2. `REALM/SEIHR.py` - An illustrative example used in the case study of our paper. The model contains 8 compartments and 30 decision periods in order to minimize the number of infections and deaths via optimizing the allocation of COVID-19 test and hospital ward under unknown characteristics of Omicron variants. 
3. `REALM/IHRD.py` - An illustrative example used in the case study of our paper, which is a simplificated version of `REALM/SEIHR.py`. It contains 4 compartments and 30 desicion periods to optimize the allocation of hospital wards and ICUs.
4. `REALM/DatasetMD.py` - The parameter settings generated by the open data set from Maryland.gov (opendata.maryland.gov)

In the following section, we provide a guideline to show the functions of `REALM/REAML.py`
## Guideline
### Step 1. Define model and model size

```
# Input dataset 
data = DatasetMD.Coviddata_MD()  
# Initialize a model 
user = REALM.REALM() 
# Initialize the value of period (T) 
period = data.period  
user.set_time(time=period)   
# Initialize the number of group (J)  
group = data.group 
user.set_group(group=group)  
# Initialize the name of compartments by function ``#.set_all_compartment''
population = data.compartment_population 
compartment = ['S','E','I','M','Q','H','R','D']
user.set_all_compartment(name=compartment)
compart_num = len(compartment) # number of compartments
```
Initialize the population of each compartment at time 1 by the function `#.set_population` with two inputs:
1) Input `compartment` is the name of a compartment;
2) Input `population` is a list with J float/int components representing the population of groups.
```
for i in range(compart_num):
    user.set_population(compartment=compartment[i], population=population[i])
```

### Step 2. Define decision variable
Define the flow variables $x^{n,m}_{j,t}$ of the model by function `#.set_flow_variable`
There are four inputs:
1) Inputs `n` and `m` are defined the flow outgoing from compartment `n` and incoming to compartment `m`;
2) Inputs `xupper` and `xlower` are OPTIONAL, representing the upper and lower bounds of the flow variable.
   The format of `xupper` can be 
   (a) a float/int number, which means for all periods and groups, the components in $x^{n,m}$ are same; 
   (b) a list including $T$ components, which means the upper bounds of the components for all groups are same; 
   (c) a list including $J$ components, which means the upper bounds of the components in all periods are same, if $J$ = $T$, rule (c) is prior to rule (b);
   (d) a list including $J*T$ components;
   The default value of `xupper` for all groups and all times is 1e+20;
   The format of `xlower` is same to `xupper`, and its default value is 0
```
S = 6
Test_capacity = [30000 for t in range(period)]
Test_probability = [0.05*(i+1) for i in range(S)]
user.set_flow_variable(n='Q', m = 'H', xupper=[[1000 for t in range(period)] for j in range(group)],
                      xlower=[[0 for t in range(period)] for j in range(group)])
user.set_flow_variable(n='I', m = 'M', xupper=[[Test_capacity[t]*Test_probability[-1]
                                            for t in range(period)] for j in range(group)],
                      xlower=[[0 for t in range(period)] for j in range(group)])
user.set_flow_variable(n='I', m = 'Q', xupper=[[Test_capacity[t]*Test_probability[-1]
                                            for t in range(period)] for j in range(group)],
                      xlower=[[0 for t in range(period)] for j in range(group)])
```
Define the customized variables (e.g., facility location, capacity) by function `#.set_custom_variable`
There are four inputs:
1) Input `name` is the name of a customized variable, and the format should be string;
2) the second input `xupper` is OPTIONAL and defines the upper bound of variable. The format should be float or int and the default value is 1e+20
3) the third input `xlower` is OPTIONAL and defines the lower bound of variable. The format should be float or int and the default value is 0
4) the fourth input `types` is OPTIONAL, and define the type of variable. There are three types of variable: `B` means binary variable; `C` means continuous variable; `I` means integer variable. The default value is `C`.  
We can also use list to define a set of variables (see variable `u` as below)
```
for j in range(group):
    for s in range(S):
        for t in range(period):
            user.set_custom_variable(name='z.' + str(j) + '.' + str(t) + '.' + str(s), xlower=0)
            user.set_custom_variable(name='phi1.' + str(j) + '.' + str(t) + '.'+str(s), xlower=-1e20)
            user.set_custom_variable(name='phi2.' + str(j) + '.' + str(t) + '.'+str(s), xlower=0)
user.set_custom_variable(name=['u.' + str(j) + '.' + str(s) for j in range(group) for s in range(S)],
                         types=['B' for j in range(group) for s in range(S)],
                         xupper=[1 for j in range(group) for s in range(S)],
                         xlower=[0 for j in range(group) for s in range(S)])
```

## Step 3 Define transition probability between compartment and compartment  
Define the decision-independent transition probability by function `#.set_transition_compartment` with four inputs.
1) Inputs 'n' and 'm' are defined the flow outgoing from compartment 'n' and incoming to compartment 'm';
2) Input 'prob' is a $J * T$ list, representing the transition probability from compartment 'n' to 'm' in group $j$ in time $t$.
   The format of 'prob' can be 
   (a) a float/int number, which means for all $t in [T]$ and $j in [J]$, the components in $q^{n,m}$ are same;   
   (b) a list with $T$ components, which means the upper bounds of the components for $j in [J]$ are same;   
   (c) a list with $J$ components, which means the upper bounds of the components for all $t in [T]$ are same, if $J = T$, rule (c) is prior to rule (b);   
   (d) a list including $J*T$ components;  
3) Input `opt` is OPTIONAL. If `opt='delate'`, all transition probability from compartment `n` will be removed.
```
TransitionProb = [('E','I'), ('I','R'), ('I','D'), ('M','R'), ('Q','D'), ('H','D'), ('H','R')]
q = data.q
for i in TransitionProb:
    user.set_transition_compartment(n=i[0], m=i[1], prob=q[i])
```
Define the decision-dependent transition probability eta between a pair of compartments by function `#.set_transition_compartment_dp`. There are ten inputs:
1) the first input `flow` is a tuple including four components. The first and second component are the names of start and end compartments; the third component is the index of group; and the fourth component is the index of time;
2) the second to fourth inputs `beta`, `gamma` and `alpha` are all OPTIONAL, which are the coefficients of compartment variable $X$, flow variable $x$ and constant term in the molecule of $\eta$, respectively. The formats of `beta` and `gamma` are $N*J$ list, and the default values are zero lists. The format of `alpha` is float or int, and the default value is 0.
3) the fifth to seven inputs `betadeno`, `gammadeno` and `alphadeno` are OPTIONAL, 
which are the coefficients of compartment variable $X$, 
flow variable $x$ 
and constant term in the denominator of $\eta$, 
respectively. The formats of `beta` and `gamma` are $N*J$ list, and the default values are zero lists. The format of `alpha` is float or int, and the default value is 1.
5) the eight and ninth inputs `lb` and `ub` are OPTIONAL, which are the lower and upper bounds of eta, i.e., $max(lb, \eta(X,x)) <=\eta <= min(ub, \eta(X,x))$; The default values are -1e+20 and 1e+20, respectively; Note that `lb` and `ub` are only used in the prediction model (simulation) but will be ingored in the optimization model.
6) the last input `opt` is OPTIONAL. If `opt='delate'`, all transition probability from compartment $n$ to $m$ will be removed.
```
for j in range(group):
    for t in range(period):
        betaSE = [[data.beta[t] * data.w[j] * data.w[k] / data.group_population[k]
                   if compartment[n] == 'I' else 0 for k in range(group)] for n in range(len(population))]
        gammaSE = [[0 for k in range(group)] for n in range(len(population))]
        user.set_transition_compartment_dp(flow=('S', 'E', j, t),
                                           beta=betaSE, gamma=gammaSE, alpha=0, opt=None)
```

## Step 4. Define other constraints
Define the customized linear constraint by function `#.custom_lp`.
There are nine inputs:
1) the first input `fvar` is a list including some compartment variables and flow variables. The compartment variable
       is a tuple including three components: the first component is the name of compartment; the second component is
       the index of group, and the third component is the index of time. The flow variable is a tuple including four
       components: the first and second components are the name of start and end compartments; the third component is
       the index of group and the fourth index of time.
   The dafault value is a empty list.
2) the second input `fcoef` is the list of the coefficients of variables in `fvar`. It has the same length to `fvar`;
   The dafault value is a empty list.
3) the third input `dvar` is a list including the names of some customized variables.
   The dafault value is a empty list. Note that either `fvar` or `dvar` should be defined.
4) the fourth input `dcoef` is a list of the coefficients of variables in `dvar`; It has the same length to `dvar`;
   The dafault value is a empty list.
5) the fifth input `sense` is a string representing the symbol of constraint. `L` means $Ax <= b$; `E` means $Ax=b$,
       while `G` implies '$Ax>=b$;
6) the sixth input `rhs` is a float/int number representing the value of right-hand side
7) the seventh input `name` is the name of constraint, if a constraint name is set repeatly, the coefficients of those variable equals to the values set in the last settings.
8) the eight input `label` is OPTIONAL, if the model is the deterministic model or the constraint does not contain
       compartment variables, `label` does not need to be defined; For the constraint with compartment variables in
       the robustness optimization model, `label` can be set to `Expectation` so that there is no term of `Xdagger` in
       the constraint. The label of equation constraint does not need to be defined as it always equals `Expectation`.
9) the ninth input `option` is OPTIONAL. If `opt='clear'`, then all customized linear constraints are removed.
For simplification, we only show three instances to define the linear constraints used in SEIHR model
```
pm = data.pm
pq = data.pq
attractive = 0.5
for t in range(period):
    for j in range(group):
        # x^{I,M}_{j,t} + x^{I,Q}_{j,t} <= attractive * I_{j,t}. Because label='Expectation', the constraint in the
        #   robustness model is same to that in the deterministic model. If we do not set label='Expectation' and try to
        #   solve the robustness model, the constraint will be automatically transformed as:
        #   x^{I,M}_{j,t} + x^{I,Q}_{j,t} - attractive * I_{j,t} + (attractive)^2/(2 * theta) * Idagger_{j,t}<= 0
        user.custom_lp(fvar=[('I', 'M', j, t),  ('I', 'Q', j, t), ('I', j, t)],
                       fcoef=[1, 1, -attractive],
                       sense='L',
                       rhs=0,
                       name='testAllocation.' + str(j) + '.' + str(t),
                       label='Expectation')
        # x^{I,M}_{j,t} = sum_{s in [S]} p^{M}_{j,t} z_{j,t,s}. This constraint is an equation and we do not set the
        #   value of 'label', although it contains a compartment variable.
        user.custom_lp(fvar= [('I', 'M', j, t)],
                       fcoef= [-1],
                       dvar=['z.' + str(j) + '.' + str(t) + '.' + str(s) for s in range(S)],
                       dcoef=[pm[j][t] for s in range(S)],
                       sense='E',
                       rhs=0,
                       name='Positive_ItoM.' + str(j) + '.' + str(t))
for j in range(group):
    # sum_{s in [S]} u_{j,s} = 1. This constraint is an equation and does not have compartment variables. We do not set
    # the value of 'label'.
    user.custom_lp(dvar=['u.' + str(j) + '.' + str(s) for s in range(S)],
                   dcoef=[1 for s in range(S)],
                   sense='E',
                   rhs=1,
                   name='Uequal.' + str(j))
```
Define the customized quadratic constraint by function `#.custom_qp`.
There are twelve inputs:
1) the formats of the first four inputs `fvarlp`, `fcoeflp`, `dvarlp` and `dcoeflp` are same to the inputs `fvar`,
       `fcoef`, `dvar`, `dcoef` defined in `#.custom_lp`;  
2) the fifth and seventh inputs 'fvarqp' and 'dvarqp' are the lists with the same formats to 'fvarlp' and 'dvarlp',
       respectively, which are the quadratic terms (i.e., variable^2);  
3) the sixth and eighth inputs `fcoefqp` and `dcoefqp` are the lists of the coefficients of the components in `fvarqp`
       and 'dvarqp', respectively;  
4) the ninth, tenth and eleventh inputs `sense`, `rhs` and `name` are same to those defined in `#.custom_lp`;  
5) the twelfth input `option` is OPTIONAL. If `opt='clear'`, then all customized quadratic constraints are removed.
For simplification, we only show the quadratic constraints used in SEIHR model as below.
       That is, $$0.25 * (\phi_1)^2 + C_{j,t,s} <= 0.25 * (\phi_2)^2$$
```
for t in range(period):
    for j in range(group):
        for s in range(S):
            user.custom_qp(dvarqp=['phi1.' + str(j) + '.' + str(t) + '.' + str(s),
                                   'phi2.' + str(j) + '.' + str(t) + '.' + str(s)],
                           dcoefqp=[0.25, -0.25],
                           sense='L',
                           rhs= -Test_capacity[t] * Test_probability[s] * data.bhat[j],
                           name='SOC.' + str(j) + '.' + str(t) + '.' + str(s))
```

## Step 5. Define objective
Define the minimization (sense='min') or maximization (sense='max') problem by function `#.set_objectivetype`.
```
user.set_objectivetype(sense='min')
```
Define the coefficient values of decision variables in the objective function by function `#.set_objective`.
There are three inputs:
1) the first input 'state' represents the name of variables. There are three types of 'state': 
    (a) a tuple with three components (compartment name, index of group and index of time), which can represent the compartment variable
       (for example, state=('I',j, t)); 
    (b) a tuple with four components (name of start compartment, name of end
       compartment, index of group and index of time), which can represent the flow variable (for example,
       state=('I','Q', j, t)); 
    (c) a string representing the name of a customized variable;
2) the second input `value` is the coefficient value of the variable corresponding to the input `state`;
3) the twelfth input `option` is OPTIONAL. If `opt='clear'`, then all coefficients are removed.
```
cd = data.cd
ci = data.ci
for j in range(group):
    for t in range(period):
        user.set_objective(state=('I', j, t), value=ci)
user.set_objective(state=('D', j, period - 1), value=cd)
```
## Step 6. Solve and output
Define the solver, the current version only support CPLEX and Gurobi.
```
user.set_solver(solver='cplex')
```
Define the solution approach. There are three settings:
       `SF`: using step function to approximate the desicion- dependent transition probability and solve the model;
       `ME`: using McCormick envelopes to approximate the desicion-dependent transition probability and solve the
             model;
       `SO`: using simulation-optimization approach to obtain near-optimal solution. This approach depends on
             the initial solution of flow variables. In default, the initial solution is automatically generated by
             'ME' approach. Also, we can use the function `#.set_initial_solution` with three inputs:
             `compartment1` and `compartment2` are the start and end compartments associated with a flow variable.
             `val` is a $J*T$ list and each component is the value of group $j$ in time $t$. For example:
              user.set_initial_solution(compartment1='S', compartment2='SS', val=[[50 for t in range(period)] for j in range(group)])
```
user.set_approximation(opt='SO')
```
If users use the 'SO' approach to solve the model, the log stream can be recorded by the function `#.set_log_stream_SO`.
There are two inputs:
1) the first input `label` is set to 1 if users want to record the log, otherwise 0 (default).
2) the second inout `file` is the path and name of the file (.txt)
```
user.set_log_stream_SO(label=1, file='SEIHR/log_SEIHR_exp')
```
Solve the model by function `#.solve`
There are three inputs:
1) the first input is to set the type of model (i.e., `Expectation` for determinisitc model or `Robustness` for robustness model);
2) the second input `ct` is OPTIONAL representing the computational time. Note that for `SF` and `ME` approaches, `ct`
       is the total computational time, while for `SO` approach, it is the computational time in each iteration. If
       users do not set a value to this input, the solving procedure will be stopped until the optimal solution is
       obtained.
3) the third input `target` is the target used in the robustness model, i.e., the objective value should be no greater
       than the target. This input is useless for the deterministic model.
The output is a tuple with five components if there exists a feasible solution. Otherwise the output equals 0.
1) the first component is the status of solving procedure to show either the solution is optimal or feasible;
2) the optimal objective value;
3) the list of compartment variables, which is a $N*J*T$ list;
4) the list of flow variables, which is a $N*N*J*T$ list. Note that for the undefined flow variables, the value in the
       list is set to 0;
5) the dictionary associated with customized variables. Each key in the dictionary is the name of a customized variable.
```
(status, obj, Xopt, xopt, Xc) = user.solve(label='Expectation', ct=3600)
```
To get a partial solutions, we can also use the following functions
Function `#.get_solution_compartment` is used to get the value of compartment variables.
1) the input is the list of the names of some compartments;
2) the output is a dictionary, where each key is a compartment name and the associated value is a $J*T$ list representing the population of group $j$ at time $t$.
```
Xsolution_exp = user.get_solution_compartment(compartment=compartment)
```
Function `#.get_solution_flow_variable` is used to get the value of flow variables.
1) the first input `compartmentfrom` is the list of the names of the start compartments;
2) the second input `compartmentto` is the list of the names of the end compartments. The length of `compartmentto`
       is same to `compartmentfrom`;
3) the output is a dictionary, where each key is a flow variable from a compartment to another. The associated value
       is a $J*T$ list representing the flow of group $j$ at time $t$.
```
xsolution_exp = user.get_solution_flow_variable(compartmentfrom=['I','I','Q'],compartmentto=['M','Q','H'])
```
Function `#.get_solution_flow_variable` is used to get the value of flow variables.
1) the input `name` is the list of the names of the customized variables;
2) the output is a dictionary, where each key is a customized variable. The associated value is a number.
```
Xcustom_exp = user.get_solution_custom_variable(name=
                                          ['u.' + str(j) + '.' + str(s) for s in range(S) for j in range(group)]
                                          + ['phi1.' + str(j) + '.' + str(t) + '.'+str(s)
                                             for s in range(S) for j in range(group) for t in range(period)]
                                          + ['phi2.' + str(j) + '.' + str(t) + '.'+str(s)
                                             for s in range(S) for j in range(group) for t in range(period)]
                                          + ['z.' + str(j) + '.' + str(t) + '.' + str(s)
                                             for s in range(S) for j in range(group) for t in range(period)])
```
Print the solution based on the solution obtained by functions `#.get_solution_compartment`,
       `#.get_solution_flow_variable` and `#.user.get_solution_custom_variable`
There are three OPTIONAL inputs: `X` for compartment variables; `x` for flow variables; `xc` for customized variables.
```
user.Solution_print(X=Xsolution_exp, x=xsolution_exp, xc=None)
```
## Step 7. Simulation 
Generate the samples corresponding to the random transition probability relative to the reference transition
       probability following uniform distribution at compartment level by `#.Sample_generation`
There are five inputs:
1) the first input `n` is the list of start compartments;
2) the second input `m` is the list of end compartments, which length is same to the first input `n`;
3) the third input `lb` is the list of lower bounds of random transition probabilities between all pairs of start and end compartments;
4) the fourth input `ub` is the list of upper bounds of random transition probabilities between all pairs of start and end compartments;
5) the fifth input is to define the sample size.
The output is a $sample * N * N$ list.
The following example is to generate 1000 samples corresponding to random transition probability from compartment $S$
       to $E$ and from compartment $I$ to $D$. They following a $Uniform(1, 1.1)$ and Uniform $(0.9,1.1)$, respectively.
'''
sample = 1000
randomq = user.Sample_generation(n=['S','I'], m=['E','D'], lb=[1, 1], ub=[0.9, 1.1], size=sample)
#Define the flow variables (user.x) in simulation (prediction)
x = [[[[0 for t in range(period)] for j in range(group)] for m in range(compart_num)] for n in range(compart_num)]
x[2][3] = [[xopt[2][3][j][t] for t in range(period)] for j in range(group)]  # flow variable from I to M
x[2][4] = [[xopt[2][4][j][t] for t in range(period)] for j in range(group)]  # flow variable from I to Q
x[4][5] = [[xopt[4][5][j][t] for t in range(period)] for j in range(group)]  # flow variable from Q to H
user.x = x
```
Simulation via function `#.Prediction`
The input is a list, which is dependent on the prediction method (deterministic/stochastic/robust prediction for
       upper and lower bounds)
For the deterministic prediction, the input `opt` equals
1) `['D']`: using the deterministic prediction model to generate the population of compartments;
2) `['D', 'stair']`: using the deterministic prediction model to generate the population of compartments, where the
     decision-dependent transition probability is approximated by step function. The step is 5*10^(-5);
3) `['D', None, random]`: using the deterministic prediction model to generate the population of compartments under
     random transition probability. 'random' is a $N*N$ list representing the relative value between the true
     transition probability and the reference transition probability.
4) `['D', None, random]`: using the deterministic prediction model to generate the population of compartments under
     random transition probability, where the decision-dependent transition probability is approximated by step
     function.
For the stochastic prediction, the input 'opt' equals
1) `['S']`: using the stochastic prediction model to generate the population of compartments;
2) `['S', random]`: using the stochastic prediction model to generate the population of compartments under
     random transition probability.
To generate the lower bound via the robust prediction, the input 'opt' equals
`['RL', theta, coef]`: `RL` defines the robust prediction; theta is an OPTIONAL float/int number (default 10). A larger
     value represents more conversative level of lower bound; coef is an OPTIONAL float/int number (default 1), which
     is the coefficient of the compartments.
To generate the upper bound via the robust prediction, users only need to replace `RL` by `RU` in the input `opt`.
The output is the simulated compartments, which is a $N*J*T$ list.
```
Xsim_exp = [0 for s in range(sample)]
for s in range(sample):
    Xsim_exp[s] = user.Prediction(opt=['D', None, randomq[s]])
```

## Step 8. Save results
Save the results by the function `#.save_result`.
There are five inputs:
1) the first input `filename` is the path and name of the excel file (.xlsx) to record the results;
2) the second input `compartment` (OPTIONAL) is the simulated value of compartments, which is a $sample * N * N$ list;
3) the third input `dvar` (OPTIONAL) is the value of flow variables obtained by the optimization model, which is a
       $N * N * J * T$ list;
4) the fourth input `custom` (OPTIONAL) is the value of customized variables obtained by the optimization model.
       `custom` is a dictionary, where each key is a customized variable. The associated value is a number;
5) the fifth input `lhs` (OPTIONAL) is a list to record the left hand side of the objective function and constraints
       based on the simulated population of compartments. Each component of the input `lhs` is a list including two
       components, where the first component is the name of constraints/objective and the second component is the
       list including all simulation value of the left-hand side of the constraint/ the simulation objective
       corresponding to all samples.
```
lhs = [['objective', [sum([Xsim_exp[s][2][j][t] * ci + Xsim_exp[s][-1][j][t] * cd for j in range(group)])
                             for s in range(sample)]]]
user.save_result(filename='SEIHR/resultSEIHR_exp', compartment=Xsim_exp, dvar=xopt, custom=Xcustom_exp, lhs=lhs)
```
